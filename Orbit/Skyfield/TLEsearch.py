# -*- coding: utf-8 -*-
"""sat_comm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tRcN6XrHyHMKivzBwLMcUPX75OqrLabd
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install skyfield==1.48

# Commented out IPython magic to ensure Python compatibility.
# %pip install lowtran

# Commented out IPython magic to ensure Python compatibility.
# %pip install poliastro

import skyfield.api
from skyfield.api import load, Topos, utc
from skyfield.sgp4lib import EarthSatellite
from skyfield.constants import AU_KM, DAY_S
from skyfield.functions import length_of
import numpy as np

from skyfield.api import load, wgs84, Loader
from math import radians
import lowtran
from datetime import datetime, timedelta
from skyfield.positionlib import ICRF

load = Loader('./skyfield-data')
eph = load('de421.bsp')

ITRF = wgs84
earth = {
    'geoid': wgs84,
    'radius_m': wgs84.radius.m,
    'flattening': wgs84.inverse_flattening,
    'polar_radius': wgs84.polar_radius.m
}

class Satellite:
  def __init__(self, tle='', simType='tle', incAngle=0, satAlt=0):

    self.simType = simType
    self.ts = load.timescale()
    self.satellite = load('de421.bsp')

    if simType == 'tle':

      self.tleList = tle
      self.tleObject = EarthSatellite(self.tleList[0],
                                     self.tleList[1],
                                     name="sat",
                                     ts=load.timescale())
      #self.t = t
      #self.position = self.propagator.position.km
      #self.velocity = self.propagator.velocity.km_per_s
      self.simType = 'tle'

    elif simType == 'polOrbPass':

      self.incAngle = radians(incAngle)
      self.satAlt = satAlt
      #self.t = t
      self.propagator = self.satellite.at()
      self.position = self.propagator.position.km
      self.velocity = self.propagator.velocity.km_per_s
      self.simType = 'polOrbPass'

    else:
      self.simType = ' '

    def setSimTLE(self, tle):
      self.tleList = tle
      self.tleObject = EarthSatellite(tle[0], tle[1], eph)
      self.propagator = self.tleOject.at()
      self.position = self.propagator.position.km
      self.velocity = self.propagator.velocity.km_per_s
      self.simType = 'tle'
      return self.position, self.velocity

    def setSimPolOrbPass(self, incAngle, satAlt):
      self.incAngle = radians(incAngle)
      self.satAlt = satAlt
      self.propagator = self.satellite.at(self.t)
      self.position = self.propagator.position.km
      self.velocity = self
      self.simType = 'polOrbPass'
      return self.position, self.velocity

    def setSimType(self, simType):
      self.simType = simType
      return self.simType

    def setIncAngle(self, incAngle):
      self.incAngle = radians(incAngle)
      return self.incAngle

    def setSatAlt(self, satAlt):
      self.satAlt = satAlt
      return self.satAlt

    def getSimType(self):
      return self.simType

    def getIncAngle(self):
      return self.incAngle

    def getSatAlt(self):
      return self.satAlt

    def getPos(self):
      return self.position

    def getVel(self):
      return self.velocity

    def getT(self):
      return self.t

    def isTLE(self):
      return (self.simType == 'tle')

    def isPolOrbPass(self):
      return (self.simType == 'polOrbPass')

tleMicius = ['1 41731U 16051A   21117.42314584  .00000696  00000-0  30260-4 0  9998',
             '2 41731  97.3499  30.8507 0012844 347.0485 124.2616 15.25507799261429']

ts = skyfield.api.load.timescale()

#sat
satellite = Satellite(tle=tleMicius, simType='tle')



class GroundStationSkyfield:
  def __init__(self, lat, lon, alt, name):
    self.latitude = lat
    self.longitude = lon
    self.altitude = alt
    self.name = name
    self.topos = Topos(latitude_degrees=self.latitude, longitude_degrees=self.longitude, elevation_m=self.altitude)

  def get_position(self, t):
    geocentric = self.topos.at(t)
    return geocentric.position.km
  def get_subpoint(self, t):
    geocentric = self.topos.at(t)
    subpoint = geocentric.subpoint()
    return subpoint

#Paris
latParis = 48.857
longParis = 2.352
altParis = 80.
nameParis = 'Paris'
sationParis = GroundStationSkyfield(lat=latParis, lon=longParis, alt=altParis, name=nameParis)

# Delft
latDelft = 52.012
longDelft = 4.357
altDelft = 0.
staDelft = GroundStationSkyfield(latDelft, longDelft, altDelft, 'Delft')

staDelft.get_subpoint(satellite.ts.utc(2021, 5, 15, 0, 0, 0)).elevation.length()

atmModel = {'TROPICAL': 1,
            'MIDLAT_SUMMER': 2,
            'MIDLAT_WINTER': 3,
            'SUBARCTIC_SUMMER': 4,
            'SUBARCTIC_WINTER': 5,
            'US_STANDARD': 6
            }
# aerosol models
aeroModel = {'NO_AEROSOLS': 0,
             'RURAL_23KM': 1,
             'RURAL_5KM': 2,
             'NAVY': 3,
             'MARITIME': 4,
             'URBAN_5KM': 5,
             'TROPOSPHERIC': 6,
             'USER_DEFINED': 7,
             'FOG1': 8,
             'FOG2': 9}
# mode of execution IEMSCT
execMode = {'TRANSMITTANCE_MODE': 0,
            'THERMAL_RADIANCE_MODE': 1,
            'RADIANCE_MODE': 2,
            'TRANSMITTED_SOLAR_IRRADIANCE': 3}

class AtmosphereTransmittanceModel:
  def __init__(self, wavelength, altitude, model='TROPICAL', aerosolModel='NO_AEROSOLS', visibility=0. ):
    self.wavelength = wavelength
    self.altitude = altitude
    self.c1 = {'h1': float(self.altitude/1000),
                  'wlshort': float(self.wavelength*1e9),
                  'wllong': float(self.wavelength*1e9),
                  'wlstep': 10,
                  'vis': float(visibility),
                  'gndAlt': float(self.altitude/1000)
                  }
        # set the atmospheric model
    if model in atmModel:
      self.c1['model'] = atmModel[model]
      self.model = model
    else:
      print('[WARNING] Model '+model+' does not exist: use default TROPICAL model.')
      self.c1['model'] = atmModel['TROPICAL']
      self.model = 'TROPICAL'
        # set the aerosol model
    if aerosolModel in aeroModel:
      self.c1['ihaze'] = aeroModel[aerosolModel]
      self.aerosolModel = aerosolModel
    else:
      print('[WARNING] Aerosol model '+aerosolModel+' does not exist: use default NO_AEROSOLS model.')
      self.c1['ihaze'] = atmModel['NO_AEROSOLS']
      self.aerosolModel = 'NO_AEROSOLS'

  def calculateTransmittance(self,elevation):
    self.c1['itype'] = 3
    self.c1['iemsct'] = 0
    if elevation > 0:
      self.c1['angle'] = 90 - elevation
      return float(lowtran.golowtran(self.c1).transmission.values)
    else:
      return 0.

  def calculateTransmittanceHorizontal(self,distance):
    self.c1['itype'] = 1
    self.c1['iemsct'] = 0

    self.c1['range_km'] = float(distance/1000)

    return float(lowtran.golowtran(self.c1).transmission.values)

  def calculateTransmittanceSlant(self,h2,distance):
    self.c1['itype'] = 2
    self.c1['iemsct'] = 0
    self.c1['h2'] = float(h2/1000)
    self.c1['range_km'] = float(distance/1000)
    return float(lowtran.golowtran(self.c1).transmission.values)

t = ts.utc(2019, 4, 7, 23, 6)

satellite = EarthSatellite(tleMicius[0], tleMicius[1], name="sat", ts=load.timescale())

auckland = Topos('36.852664 S', '174.768017 E')
difference = satellite - auckland

topocentric = difference.at(t)

alt, az, distance = topocentric.altaz()

alt

class SimpleDownlinkChannel:
  def __init__(self,sat,gs,wl,atmModel=None):

    self.satellite = sat
    self.groundStation = gs
    self.wavelength = float(wl)

    # initialize the atmospheric transmittance model
    if atmModel is None:
      self.atm = AtmosphereTransmittanceModel(self.wavelength, self.groundStation.altitude)
    else:
      self.atm = atmModel

  def calculateChannelParameters(self, timeList):
    if self.satellite.simType == 'isPolOrbPass':

      psi = self.groundStation.latitude
      deltaI = self.satellite.incAngle
      hs = self.satellite.satAlt
      deltaMin = np.arccos( np.cos(psi)*np.cos(deltaI) / np.sqrt(1 - ( np.cos(psi)*np.sin(deltaI) )**2) )
      tMin = timeList[ int(len(timeList)/2) ]

      # Earth parameters (from Daniele's code)
      Rt = 6.37e6     # Earth radius
      M = 5.97e24     # Earth mass
      G = 6.67e-11    # Gravitational constant

      Omega = np.sqrt( G*M / (Rt + hs)**3)

      relTime = np.array([(timeList[i] - tMin).total_seconds() for i in range(len(timeList))])
      delta = Omega * relTime + deltaMin
      Zc = np.arccos( np.sin(psi)*np.sin(delta) + np.cos(psi)*np.cos(delta)*np.cos(deltaI) )
      Z = np.arcsin( (Rt+hs)*np.sin(Zc) / np.sqrt( Rt**2 + (Rt+hs)**2 - 2*Rt*(Rt+hs)*np.cos(Zc)) )
      elevation = 90 - np.rad2deg(Z)
      channelLength = -Rt*np.cos(Z) + np.sqrt( (Rt*np.cos(Z))**2 + 2*Rt*hs + hs**2)
      atmTrans = np.array([self.atm.calculateTransmittance(elevation[i]) for i in range(len(timeList))])

    elif self.satellite.simType == 'tle':

      channelLength = np.zeros( (len(timeList),) )
      atmTrans = np.zeros( (len(timeList),) )
      elevation = np.zeros( (len(timeList),) )
      #diff = np.zeros( (len(timeList),) )
      azimutal = np.zeros( (len(timeList),))
      dist = np.zeros( (len(timeList),))

      for i in range(len(timeList)):

        t = ts.utc(timeList[i].year,timeList[i].month,timeList[i].day,timeList[i].hour,timeList[i].minute,timeList[i].second)

        self.satellite.propagator = self.satellite.tleObject.at(t)
        self.satellite.position = self.satellite.propagator.position.km
        self.satellite.velocity = self.satellite.propagator.velocity.km_per_s
        self.groundStation.position = self.groundStation.get_position(t)

        channelLength[i] = length_of(self.satellite.position - self.groundStation.position)
        #topocentric = self.satellite.propagator - self.groundStation.topos
        #alt, az, _ = topocentric.at(t).altaz()
        #elevation[i] = alt.degrees

        #diff =  wgs84.latlon(latitude_degrees=self.groundStation.latitude,
        #                     longitude_degrees=self.groundStation.longitude,
        #                     elevation_m=self.groundStation.altitude) - wgs84.subpoint_of(satellite.propagator)
        diff = self.satellite.tleObject - Topos(latitude_degrees=self.groundStation.latitude,
                                                 longitude_degrees=self.groundStation.longitude,
                                                 elevation_m=self.groundStation.altitude)
        #diff = wgs84.subpoint(satellite.position).elevation - wgs84.subpoint(self.groundStation.position).elevation
        #diff = wgs84.subpoint_of(satellite.propagator) - self.groundStation.get_subpoint(t)
        #diff = wgs84.subpoint_of(satellite.propagator).at(satellite.ts.utc(2021, 5, 15, 10, 0, 0)).subpoint() - self.groundStation.get_subpoint(t).at(t).subpoint()

        alt, az, distance = diff.at(t).altaz()
        elevation[i] = alt.degrees
        azimutal[i] = az.degrees
        dist[i] = distance.km

        #atmTrans[i] = self.atm.calculateTransmittance(self.groundStation.get_subpoint(t, self.satellite.tleObject).elevation.km)
        #atmTrans[i] = self.atm.calculateTransmittance(elevation[i])
        #elevation[i] = self.groundStation.get_subpoint(t).elevation.km
        #elevation[i] = self.groundStation.get_subpoint(t).elevation.km
        #elevation[i] = wgs84.subpoint(self.satellite.position, self.groundStation.topos).latitude.degrees
        #elevation[i] = wgs84.subpoint_of(satellite.propagator).at(t).distance()
        #elevation[i] = np.rad2deg(elevation[i])
        #elevation[i] = self.groundStation.get_subpoint(t).elevation.length()
        #elevation[i] = alt.degrees

        self.channelLength = channelLength
        #self.atmTrans = atmTrans
        self.elevation = elevation
        self.azimutal = azimutal
        self.dist = dist

        #return self.channelLength, self.atmTrans, self.elevation
    return (channelLength, elevation, azimutal, dist, atmTrans)

EarthSatellite(tleMicius[0], tleMicius[1], name="sat", ts=load.timescale())

wgs84.latlon(latitude_degrees=sationParis.latitude, longitude_degrees=sationParis.longitude, elevation_m=sationParis.altitude)

wgs84.latlon(latitude_degrees=sationParis.latitude, longitude_degrees=sationParis.longitude, elevation_m=sationParis.altitude).elevation



wgs84.subpoint_of(satellite.propagator).elevation

wgs84.subpoint_of(satellite.propagator).at(satellite.ts.utc(2021, 5, 15, 10, 0, 0))

wgs84.subpoint_of(satellite.propagator)



wgs84.latlon(latitude_degrees=latParis,
             longitude_degrees=longParis,
             elevation_m=altParis).at(satellite.ts.utc(2021, 5, 15, 10, 0, 0)).subpoint()

wgs84.subpoint_of(satellite.propagator).at(satellite.ts.utc(2021, 5, 15, 10, 0, 0))

staDelft.get_subpoint(satellite.ts.utc(2021, 5, 15, 10, 0, 0)).at(satellite.ts.utc(2021, 5, 15, 10, 0, 0)) - wgs84.subpoint_of(satellite.propagator).at(satellite.ts.utc(2021, 5, 15, 10, 0, 0))

staDelft.get_subpoint(satellite.ts.utc(2021, 5, 15, 10, 0, 0))

staDelft.get_subpoint(satellite.ts.utc(2021, 5, 15, 10, 0, 0)).at(satellite.ts.utc(2021, 5, 15, 10, 0, 0)).subpoint()

wgs84.subpoint_of(satellite.propagator).at(satellite.ts.utc(2021, 5, 15, 10, 0, 0)).subpoint()

diff = wgs84.subpoint_of(satellite.propagator).at(satellite.ts.utc(2021, 5, 15, 10, 0, 0)).subpoint() - staDelft.get_subpoint(satellite.ts.utc(2021, 5, 15, 10, 0, 0)).at(satellite.ts.utc(2021, 5, 15, 10, 0, 0)).subpoint()

alt, az, _ = diff.at(satellite.ts.utc(2021, 5, 15, 10, 0, 0)).altaz()

az.degrees

alt.degrees

#x,y,z = wgs84.subpoint_of(satellite.propagator).at(satellite.ts.utc(2021, 5, 15, 50, 0, 0)).xyz.km

#wgs84.subpoint_of(satellite.propagator).elevation

wavelength = 1550e-9

downSatParis = SimpleDownlinkChannel(satellite, sationParis, wavelength)

downDelft = SimpleDownlinkChannel(satellite, staDelft, wavelength)

downSatParis

startTime = datetime(2021, 5, 15, 0, 0, 0)
endTime = datetime(2021, 5, 15, 0, 20, 0)
timeStep = timedelta(seconds = 10.)

timeList = []
while startTime < endTime:
  timeList.append(startTime)
  startTime += timeStep

channeLength, elevation, azimutal, distance = downSatParis.calculateChannelParameters(timeList)

channDelft, elevationDelft, azimutaDelft, distanceDelft = downDelft.calculateChannelParameters(timeList)

times = np.array([ (timeList[i]-timeList[0]).seconds  for i in range(len(timeList)) ])

import matplotlib.pyplot as plt

plt.figure(figsize=(18,6))
plt.subplot(131)
plt.plot(times/60, channeLength)
plt.plot(times/60, channDelft)
plt.ylabel('Channel length [km]')
plt.xlabel('Passage time [minutes]')
plt.legend(['Sate-P','Sat-Delft'], prop={'size': 15})

plt.figure(figsize=(20,6))
plt.subplot(131)
plt.plot(times/60, distance/1000)
plt.plot(times/60,distanceDelft/1000)
plt.legend(['Sate-P','Sat-Delft'], prop={'size': 15})

plt.figure(figsize=(20,6))
plt.plot(times/60,elevation,'b')
plt.plot(times/60,elevationDelft,'r')
#plt.plot(times/60,elSatBarcelona,'g')
plt.ylabel('Elevation [degrees]',fontsize=15)
plt.xlabel('Passage time [minutes]',fontsize=15)
plt.tick_params(axis='both', labelsize=13)
plt.legend(['Sate-P','Sat-Delft'], prop={'size': 15})

plt.figure(figsize=(20,6))
plt.subplot(131)
plt.plot(times/60, azimutal)
plt.plot(times/60, azimutaDelft)
plt.ylabel('Azimuth [deg]')
plt.xlabel('Passage time [minutes]')
plt.legend(['Sate-P','Sat-Delft'], prop={'size': 15})

plt.figure(figsize=(20,6))
plt.subplot(131)
plt.plot(azimutal, elevation)
plt.plot(azimutaDelft, elevationDelft)
plt.ylabel('Elevation [deg]')
plt.xlabel('Azimuth [deg]')
plt.legend(['Sate-P','Sat-Delft'], prop={'size': 15})

"""### Brazil : Connect Campinas 2 Manaus"""

lat_unicamp = 22.54
lon_unicamp = -47
alt_unicamp = 757
name_unicamp = 'Unicamp'
station_unicamp = GroundStationSkyfield(lat=lat_unicamp, lon=lon_unicamp, alt=alt_unicamp, name=name_unicamp)

lat_manaus = -3.12
lon_manaus = -60.
alt_manaus = 0
name_manaus = 'Manaus'
station_manaus = GroundStationSkyfield(lat=lat_manaus, lon=lon_manaus, alt=alt_manaus, name=name_manaus)

tle_StarLink_4380 = ['1 53650U 22105C   24332.14154247  .00001063  00000+0  87324-4 0  9998',
                     '2 53650  97.6556 210.6536 0003842  84.0843 276.0820 15.01262247123366']

tle_AMAZONIA_1 = ['1 47699U 21015A   24331.66896108  .00000823  00000+0  27046-3 0  9995',
                  '2 47699  98.3819  44.8584 0001784 110.4232 249.7148 14.40820713196923']

tle_ONEWEB_0185 = ['1 48220U 21031L   24331.22693468 -.00000110  00000+0 -33234-3 0  9997',
                   '2 48220  87.9027  42.6310 0001658 108.3409 251.7901 13.14502223173630']

satellite_StarLink_4380 = Satellite(tle=tle_StarLink_4380, simType='tle')

satellite_ONEWEB_0185 = Satellite(tle=tle_ONEWEB_0185, simType='tle')

satellite_AMAZONIA_1 = Satellite(tle=tle_AMAZONIA_1, simType='tle')

#wgs84.subpoint_of(satellite.propagator).elevation

wavelength = 1550e-9

downSatCampinas = SimpleDownlinkChannel(satellite_AMAZONIA_1, station_unicamp, wavelength)

downSatManaus = SimpleDownlinkChannel(satellite_AMAZONIA_1, station_manaus, wavelength)

startTime = datetime(2021, 9, 1, 0, 0, 0)
endTime = datetime(2021, 9, 2, 0, 0, 0)
timeStep = timedelta(minutes = 100.)

timeList = []
while startTime < endTime:
  timeList.append(startTime)
  startTime += timeStep

channeLength, elevation, azimutal, distance = downSatCampinas.calculateChannelParameters(timeList)

channelManaus, elevationManaus, azimutaManaus, distanceManaus = downSatManaus.calculateChannelParameters(timeList)

times = np.array([ (timeList[i]-timeList[0]).seconds  for i in range(len(timeList)) ])

import matplotlib.pyplot as plt

plt.figure(figsize=(18,6))
plt.subplot(131)
plt.plot(channeLength)
plt.plot(channelManaus)
plt.ylabel('Channel length [km]')
plt.xlabel('Passage time [minutes]')
plt.legend(['Sate-P','Sat-Delft'], prop={'size': 15})

plt.figure(figsize=(20,6))
plt.subplot(131)
plt.plot(distance/1000)
plt.plot(distanceManaus/1000)
plt.legend(['Sate-P','Sat-Delft'], prop={'size': 15})

plt.figure(figsize=(20,6))
plt.plot(elevation,'b')
plt.plot(elevationManaus,'r')
#plt.plot(times/60,elSatBarcelona,'g')
plt.ylabel('Elevation [degrees]',fontsize=15)
plt.xlabel('Passage time [minutes]',fontsize=15)
plt.tick_params(axis='both', labelsize=13)
plt.legend(['Sate-CAMP','Sat-MANAUS'], prop={'size': 15})

import plotly.express as px
#interactiv eplot
fig = px.line(y=elevation, title='Elevation')
#join other station
fig.add_scatter(y=elevationManaus, name='Elevation Manaus')
fig.show()



from astropy import units as u
from poliastro.earth import EarthSatellite
from poliastro.earth.plotting import GroundtrackPlotter
#from poliastro.examples import iss
from poliastro.util import time_range

t_range = time_range(start=datetime(2021, 5, 15, 0, 0, 0), end=datetime(2021, 5, 15, 0, 20, 0))

